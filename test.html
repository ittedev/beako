<!DOCTYPE html>
<meta charset="UTF-8">
<title>virtual_dom/load.test.js</title>
<link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
<div id="mocha"></div>
<template id="template"><style></style><p></p></template>
<div id="define_target1" style="display: none;"></div>
<div id="define_target2" style="display: none;"></div>
<div id="define_target3" style="display: none;"></div>
<div id="define_target4" style="display: none;"></div>
<div id="hack_target1" style="display: none;"></div>
<div id="hack_target2" style="display: none;"></div>
<div id="hack_target3" style="display: none;"></div>
<div id="hack_target4" style="display: none;"></div>
<div id="compact_target1" style="display: none;"></div>
<div id="compact_target2" style="display: none;"></div>
<div id="compact_target3" style="display: none;"></div>
<div id="compact_target4" style="display: none;"></div>
<div id="compact_target5" style="display: none;"></div>
<div id="sync_target1_1" style="display: none;"></div>
<div id="sync_target1_2" style="display: none;"></div>
<div id="sync_target2" style="display: none;"></div>
<div id="sync_target3" style="display: none;"></div>
<div id="sync_target4" style="display: none;"></div>
<div id="sync_target5" style="display: none;"></div>
<div id="sync_target6" style="display: none;"></div>
<div id="sync_target7" style="display: none;"></div>
<div id="sync_target8" style="display: none;"></div>
<div id="sync_target9" style="display: none;"></div>
<script src="https://unpkg.com/chai/chai.js"></script>
<script>
var i = 0
var equal = (v, p) => chai.expect(v === undefined ? v : JSON.parse(JSON.stringify(v))).deep.equal(p)
var sleep = t => new Promise(r => setTimeout(r, t || 0))
</script>
<script src="https://unpkg.com/mocha/mocha.js"></script>
<script type="module">
import {
  watch,
  receive,
  unwatch,
  reach,
  lock,
  unlock,
  load,
  patch,
  expression,
  parse,
  evaluate,
  extend,
  define,
  compact,
  hack
} from './beako.js'

mocha.setup('bdd')
class XX extends HTMLDivElement { constructor() { super() } }
class YY extends HTMLDivElement { constructor() { super() } }
customElements.define('x-x', XX, { extends: "div" })
customElements.define('y-y', YY, { extends: "div" })

describe('Data Binding', function() {

  // Test watch() function
  describe('watch()', function() {
    describe(': bio', function() {
      it('watch object', () => {
        const data = {
          x: 1
        }
        watch(data)
        equal(data.x, 1)
        data.x++
        equal(data.x, 2)
        equal(data, { x: 2 })
      })

      it('deeply watch object', () => {
        const data = {
          x: 1,
          y: {
            z: 2
          }
        }
        watch(data)
        equal(data.y.z, 2)
        data.y.z += 1
        equal(data.y.z, 3)
        equal(data, {
          x: 1,
          y: {
            z: 3
          }
        })
      })

      it('watch object exec function', () => {
        const data = {
          x: 1
        }
        let y = 0
        watch(data, () => { y = 2 })
        data.x = 2
        equal(y, 2)
      })

      it('deeply watch object exec function', () => {
        const data = {
          x: 1,
          y: {
            z: 2
          }
        }
        let y = 0
        watch(data, () => { y = 2 })
        data.y.z = 3
        equal(y, 2)
      })

      it('watch object no change exec function', () => {
        const data = {
          x: 1
        }
        let y = 0
        watch(data, () => { y = 2 })
        data.x = 1
        equal(y, 0)
      })

      it('double watch a function', () => {
        const data = {
          x: 1
        }
        let y = 0
        const f = () => { y += 2 }
        watch(data, f)
        watch(data, f)
        data.x = 2
        equal(y, 2)
      })

      it('double watch difference functions', () => {
        const data = {
          x: 1
        }
        let y = 0
        watch(data, () => { y += 2 })
        watch(data, () => { y += 2 })
        data.x = 2
        equal(y, 4)
      })
    })

    describe(': bio array', function() {
      it('watch array', () => {
        const data = [1]
        watch(data)
        equal(data[0], 1)
        data[0]++
        equal(data[0], 2)
        equal(data, [2])
      })

      it('deeply watch array', () => {
        const data = [1, [2]]
        watch(data)
        equal(data[1][0], 2)
        data[1][0] += 1
        equal(data[1][0], 3)
        equal(data, [1, [3]])
      })

      it('watch array exec function', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y = 2 })
        data[0] = 2
        equal(y, 2)
      })

      it('deeply watch array exec function', () => {
        const data = [1, [2]]
        let y = 0
        watch(data, () => { y = 2 })
        data[1][0] = 3
        equal(y, 2)
      })

      it('watch array no change exec function', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y = 2 })
        data[0] = 1
        equal(y, 0)
      })

      it('double watch array a function', () => {
        const data = [1]
        let y = 0
        const f = () => { y += 2 }
        watch(data, f)
        watch(data, f)
        data[0] = 2
        equal(y, 2)
      })

      it('double watch array difference functions', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y += 2 })
        watch(data, () => { y += 2 })
        data[0] = 2
        equal(y, 4)
      })

      it('watch array push a item', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y = 2 })
        data.push(3)
        equal(y, 2)
        equal(data, [1, 3])
      })

      it('watch array push items', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y = 2 })
        data.push(3, 4)
        equal(y, 2)
        equal(data, [1, 3, 4])
      })

      it('watch array unshift a item', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y = 2 })
        data.unshift(3)
        equal(y, 2)
        equal(data, [3, 1])
      })

      it('watch array unshift items', () => {
        const data = [1]
        let y = 0
        watch(data, () => { y = 2 })
        data.unshift(3, 4)
        equal(y, 2)
        equal(data, [3, 4, 1])
      })

      it('watch array pop', () => {
        const data = [1, 3]
        let y = 0
        watch(data, () => { y = 2 })
        data.pop()
        equal(y, 2)
        equal(data, [1])
      })

      it('watch array shift', () => {
        const data = [1, 3]
        let y = 0
        watch(data, () => { y = 2 })
        data.shift()
        equal(y, 2)
        equal(data, [3])
      })

      it('watch array sort', () => {
        const data = [6, 3, 4]
        let y = 0
        watch(data, () => { y = 2 })
        data.sort((a, b) => a - b)
        equal(y, 2)
        equal(data, [3, 4, 6])
      })

      it('watch array reverse', () => {
        const data = [6, 3, 4]
        let y = 0
        watch(data, () => { y = 2 })
        data.reverse()
        equal(y, 2)
        equal(data, [4, 3, 6])
      })

      it('watch array copyWithin', () => {
        const data = [6, 3, 4]
        let y = 0
        watch(data, () => { y = 2 })
        data.copyWithin(0, 1, 2)
        equal(y, 2)
        equal(data, [3, 3, 4])
      })

      it('watch array splice', () => {
        const data = [6, 3, 4]
        let y = 0
        watch(data, () => { y = 2 })
        data.splice(1, 1, 2, 5)
        equal(y, 2)
        equal(data, [6, 2, 5, 4])
      })
    })

    describe(': spy', function() {
      it('watch a property', () => {
        const data = {
          x: 1
        }
        let y = 0
        watch(data, 'x', v => { y = v })
        data.x = 2
        equal(y, 2)
      })
      it('watch multi properties', () => {
        const data = {
          x1: 2,
          x2: 20,
          x3: 200
        }
        let y = 0
        watch(data, ['x1', 'x3'], v => { y += v })
        data.x1 = 1
        data.x2 = 10
        data.x3 = 100
        equal(y, 101)
      })

      it('double watch a function', () => {
        const data = {
          x1: 2,
          x2: 20,
          x3: 200
        }
        let y = 0
        const f = v => { y += v }
        watch(data, ['x1', 'x3'], f)
        watch(data, ['x1', 'x3'], f)
        data.x1 = 1
        data.x2 = 10
        data.x3 = 100
        equal(y, 101)
      })

      it('double watch difference functions', () => {
        const data = {
          x1: 2,
          x2: 20,
          x3: 200
        }
        let y = 0
        watch(data, ['x1', 'x3'], v => { y += v })
        watch(data, ['x1', 'x3'], v => { y += v })
        data.x1 = 1
        data.x2 = 10
        data.x3 = 100
        equal(y, 202)
      })

      it('bio and spy watch', () => {
        const data = {
          x1: 2,
          x2: 20,
          x3: 200
        }
        let y = 0
        watch(data, () => { y += 2 })
        watch(data, 'x3', v => { y += v })
        data.x1 = 1
        data.x2 = 10
        data.x3 = 100
        equal(y, 106)
      })
    })
  })

  // Test receive() function
  describe('receive()', function() {
    it('receive defined', async () => {
      const data = {
        x: 1
      }
      const data2 = await receive(data, 'x')
      equal(data2.x, 1)
    })

    it('receive multi defined', async () => {
      const data = {
        x: 1,
        y: 'hello'
      }
      const data2 = await receive(data, ['x', 'y'])
      equal(JSON.stringify(data2), '{"x":1,"y":"hello"}')
    })

    it('receive undefined', async () => {
      const data = {}
      setTimeout(() => data.x = 1, 10)
      const data2 = await receive(data, 'x')
      equal(data2.x, 1)
    })

    it('receive undefined value', async () => {
      const data = {
        x: undefined
      }
      setTimeout(() => data.x = 1, 10)
      const data2 = await receive(data, 'x')
      equal(data2.x, 1)
    })
  })

  // Test unwatch() function
  describe('unwatch()', function() {
    it('unwatch object', () => {
      const data = {
        x: 1
      }
      watch(data)
      unwatch(data)
      equal(data.x, 1)
      data.x++
      equal(data.x, 2)
      equal(data, { x: 2 })
    })

    it('unwatch nested object', () => {
      const data = {
        x: 1,
        y: {
          z: 2
        }
      }
      watch(data)
      unwatch(data)
      equal(data.y.z, 2)
      data.y.z += 1
      equal(data.y.z, 3)
      equal(data, {
        x: 1,
        y: {
          z: 3
        }
      })
    })

    it('unwatch object exec function', () => {
      const data = {
        x: 1
      }
      let y = 0
      const f = () => { y = 2 }
      watch(data, f)
      unwatch(data, f)
      data.x = 2
      equal(y, 0)
    })

    it('deeply unwatch object exec function', () => {
      const data = {
        x: 1,
        y: {
          z: 2
        }
      }
      let y = 0
      const f = () => { y = 2 }
      watch(data, f)
      unwatch(data, f)
      data.y.z = 3
      equal(y, 0)
    })

    it('unwatch a property', () => {
      const data = {
        x: 1
      }
      let y = 0
      const f = v => { y = v }
      watch(data, 'x', f)
      unwatch(data, 'x', f)
      data.x = 2
      equal(y, 0)
    })

    it('unwatch multi properties', () => {
      const data = {
        x1: 2,
        x2: 20,
        x3: 200
      }
      let y = 0
      const f = v => { y += v }
      watch(data, ['x1', 'x3'], f)
      unwatch(data, ['x1', 'x3'], f)
      data.x1 = 1
      data.x2 = 10
      data.x3 = 100
      equal(y, 0)
    })

    it('watch multi properties and unwatch a property', () => {
      const data = {
        x1: 2,
        x2: 20,
        x3: 200
      }
      let y = 0
      const f = v => { y += v }
      watch(data, ['x1', 'x3'], f)
      unwatch(data, 'x1', f)
      data.x1 = 1
      data.x2 = 10
      data.x3 = 100
      equal(y, 100)
    })
  })

  describe('reach()', function() {
    it('reach object', () => {
      const data = {
        x: 1
      }
      let y = 0
      watch(data)
      reach(data, () => { y = 2 })
      data.x++
      equal(y, 2)
    })
    it('reach nested object', () => {
      const data = {
        x: 1,
        y: {
          z: 3
        }
      }
      let y = 0
      watch(data.y)
      reach(data, () => { y = 2 })
      data.x += 1
      data.y.z += 1
      equal(y, 2)
    })
    it('reach no watch object', () => {
      const data = {
        x: 1
      }
      let y = 0
      reach(data, () => { y = 2 })
      data.x++
      equal(y, 0)
    })
    it('double reach a function', () => {
      const data = {
        x: 1
      }
      let y = 0
      watch(data)
      const f = () => { y += 2 }
      reach(data, f)
      reach(data, f)
      data.x++
      equal(y, 2)
    })
    it('double reach difference functions', () => {
      const data = {
        x: 1
      }
      let y = 0
      watch(data)
      reach(data, () => { y += 2 })
      reach(data, () => { y += 2 })
      data.x++
      equal(y, 4)
    })
  })

  describe('lock()', function() {
    it('watch locked object', () => {
      const data = lock({
        x: 1
      })
      let y = 0
      watch(data, () => { y = 2 })
      data.x = 2
      equal(y, 0)
    })
    it('watch locked object property', () => {
      const data = lock({
        x: 1
      })
      let y = 0
      watch(data, 'x', v => { y = v })
      data.x = 2
      equal(y, 0)
    })
    it('watch locked array', () => {
      const data = lock([1])
      let y = 0
      watch(data, () => { y = 2 })
      data[0] = 2
      equal(y, 0)
    })
    it('receive locked defined', async () => {
      const data = lock({
        x: 1
      })
      const data2 = await receive(data, 'x')
      equal(data2.x, undefined)
    })
    it('unwatch locked object', () => {
      const data = {
        x: 1
      }
      watch(data)
      lock(data)
      unwatch(data)
      equal(data.x, 1)
      data.x++
      equal(data.x, 2)
      equal(data, { x: 2 })
    })
    it('reach nested locked object', () => {
      const data = {
        x: 1,
        y: {
          z: 3
        }
      }
      let y = 0
      watch(data.y)
      lock(data.y)
      reach(data, () => { y = 2 })
      data.x += 1
      data.y.z += 1
      equal(y, 0)
    })
  })
  describe('unlock()', function() {
    it('watch unlocked object', () => {
      const data = unlock(lock({
        x: 1
      }))
      let y = 0
      watch(data, () => { y = 2 })
      data.x = 2
      equal(y, 2)
    })
    it('watch unlocked object property', () => {
      const data = unlock(lock({
        x: 1
      }))
      let y = 0
      watch(data, 'x', v => { y = v })
      data.x = 2
      equal(y, 2)
    })
    it('watch unlocked array', () => {
      const data = unlock(lock([1]))
      let y = 0
      watch(data, () => { y = 2 })
      data[0] = 2
      equal(y, 2)
    })
    it('receive unlocked defined', async () => {
      const data = unlock(lock({
        x: 1
      }))
      const data2 = await receive(data, 'x')
      equal(data2.x, 1)
    })
    it('reach nested unlocked object', () => {
      const data = {
        x: 1,
        y: unlock(lock({
          z: 3
        }))
      }
      let y = 0
      watch(data.y)
      reach(data, () => { y = 2 })
      data.x += 1
      data.y.z += 1
      equal(y, 2)
    })
  })
})

describe('Virtual Dom', function() {
  describe('load()', function() {
    it('load body', () => {
      const doc = new DOMParser().parseFromString(`<body></body>`, 'text/html')
      const vtree = load(doc.body)
      equal(vtree, {
        el: {}
      })
    })

    it('load body class', () => {
      const doc = new DOMParser().parseFromString(`<body class="class-a class-b"></body>`, 'text/html')
      const vtree = load(doc.body)
      equal(vtree, {
        el: {}
      })
    })

    it('load body part', () => {
      const doc = new DOMParser().parseFromString(`<body part="part-a part-b"></body>`, 'text/html')
      const vtree = load(doc.body)
      equal(vtree, {
        el: {}
      })
    })

    it('load single element', () => {
      const doc = new DOMParser().parseFromString(`<p></p>`, 'text/html')
      const vtree = load(doc.body)
      equal(vtree, {
        children: [
          {
            tag: 'p',
            el: {}
          }
        ],
        el: {}
      })
    })

    it('load multi element', () => {
      const doc = new DOMParser().parseFromString(`<p></p><p></p>`, 'text/html')
      const vtree = load(doc.body)
    })

    it('load style element', () => {
      const doc = new DOMParser().parseFromString(`<style>a { color: red; }</style>`, 'text/html')
      const vtree = load(doc.body)
    })

    it('load script element', () => {
      const doc = new DOMParser().parseFromString(`<script>alert('hello');<\/script>`, 'text/html')
      const vtree = load(doc.body)
      equal(vtree, {
        el: {}
      })
    })
  })


  // Test patch() function
  describe('patch()', function() {
    describe(': element', function() {
      it('patch change tag', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', el }] }
        const newTree = { children: [{ tag: 'p' }] }
        const patchedTree = patch(tree, newTree)
        equal(patchedTree, {
          children: [{
            tag: 'p',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.tagName, 'P')
      })
    })

    describe(': is', function() {
      it('patch new is', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', el }] }
        const newTree = { children: [{ tag: 'div', is: 'x-x' }] }
        const patchedTree = patch(tree, newTree)
        equal(patchedTree, {
          children: [{
            tag: 'div',
            is: 'x-x',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild instanceof XX, true)
        equal(parent.firstChild === el, false)
      })

      it('patch change is', () => {
        const parent = document.createElement('div', { is : 'x-x' })
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', is: 'x-x', el }] }
        const newTree = { children: [{ tag: 'div', is: 'y-y' }] }
        const patchedTree = patch(tree, newTree)
        equal(patchedTree, {
          children: [{
            tag: 'div',
            is: 'y-y',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild instanceof YY, true)
        equal(parent.firstChild === el, false)
      })

      it('patch remove is', () => {
        const parent = document.createElement('div', { is : 'x-x' })
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', is: 'x-x', el }] }
        const newTree = { children: [{ tag: 'div' }] }
        const patchedTree = patch(tree, newTree)
        equal(patchedTree, {
          children: [{
            tag: 'div',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild instanceof XX, false)
        equal(parent.firstChild === el, false)
      })
    })

    describe(': class', function() {
      it('patch new class', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', el }] }
        const newTree = { children: [{ tag: 'div', class: ['class-a'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            class: ['class-a'],
            el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.classList.values()], ['class-a'])
      })

      it('patch add class', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.classList.add('class-a')
        const tree = { el: parent, children: [{ tag: 'div', class: ['class-a'], el }] }
        const newTree = { children: [{ tag: 'div', class: ['class-a', 'class-b', 'class-c'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            class: ['class-a', 'class-b', 'class-c'],
            el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.classList.values()], ['class-a', 'class-b', 'class-c'])
      })

      it('patch remove class', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.classList.add('class-a', 'class-b', 'class-c')
        const tree = { el: parent, children: [{ tag: 'div', class: ['class-a', 'class-b', 'class-c'], el }] }
        const newTree = { children: [{ tag: 'div', class: ['class-a', 'class-c'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          class: ['class-a', 'class-c'],
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.classList.values()], ['class-a', 'class-c'])
      })

      it('patch remove all class', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.classList.add('class-a', 'class-b', 'class-c')
        const tree = { el: parent, children: [{ tag: 'div', class: ['class-a', 'class-b', 'class-c'], el }] }
          const newTree = { children: [{ tag: 'div' }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.classList.values()], [])
      })

      it('patch set empty class', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.classList.add('class-a', 'class-b', 'class-c')
        const tree = { el: parent, children: [{ tag: 'div', class: ['class-a', 'class-b', 'class-c'], el }] }
        const newTree = { children: [{ tag: 'div', class: [] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.classList.values()], [])
      })

      it('patch no change class', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.classList.add('class-a', 'class-b')
        const tree = { el: parent, children: [{ tag: 'div', class: ['class-a', 'class-b'], el }] }
        const newTree = { children: [{ tag: 'div', class: ['class-a', 'class-b'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          class: ['class-a', 'class-b'],
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.classList.values()], ['class-a', 'class-b'])
      })
    })

    describe(': part', function() {
      it('patch new part', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', el }] }
        const newTree = { children: [{ tag: 'div', part: ['part-a'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            part: ['part-a'],
            el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.part.values()], ['part-a'])
      })

      it('patch add part', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.part.add('part-a')
        const tree = { el: parent, children: [{ tag: 'div', part: ['part-a'], el }] }
        const newTree = { children: [{ tag: 'div', part: ['part-a', 'part-b', 'part-c'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            part: ['part-a', 'part-b', 'part-c'],
            el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.part.values()], ['part-a', 'part-b', 'part-c'])
      })

      it('patch remove part', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.part.add('part-a', 'part-b', 'part-c')
        const tree = { el: parent, children: [{ tag: 'div', part: ['part-a', 'part-b', 'part-c'], el }] }
        const newTree = { children: [{ tag: 'div', part: ['part-a', 'part-c'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          part: ['part-a', 'part-c'],
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.part.values()], ['part-a', 'part-c'])
      })

      it('patch remove all part', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.part.add('part-a', 'part-b', 'part-c')
        const tree = { el: parent, children: [{ tag: 'div', part: ['part-a', 'part-b', 'part-c'], el }] }
          const newTree = { children: [{ tag: 'div' }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.part.values()], [])
      })

      it('patch set empty part', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.part.add('part-a', 'part-b', 'part-c')
        const tree = { el: parent, children: [{ tag: 'div', part: ['part-a', 'part-b', 'part-c'], el }] }
        const newTree = { children: [{ tag: 'div', part: [] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
          tag: 'div',
          el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.part.values()], [])
      })

      it('patch no change part', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.part.add('part-a', 'part-b')
        const tree = { el: parent, children: [{ tag: 'div', part: ['part-a', 'part-b'], el }] }
        const newTree = { children: [{ tag: 'div', part: ['part-a', 'part-b'] }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            part: ['part-a', 'part-b'],
            el: {}
          }],
          el: {}
        })
        equal([...parent.firstChild.part.values()], ['part-a', 'part-b'])
      })
    })

    describe(': style', function() {
      it('patch new style', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{ tag: 'div', el }] }
        const newTree = { children: [{ tag: 'div', style: 'color: red;' }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            style: 'color: red;',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.style.cssText, 'color: red;')
      })

      it('patch add style', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.style.cssText = 'color: red;'
        const tree = { el: parent, children: [{
          tag: 'div',
          style: 'color: red;',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          style: 'font-size: 1px; margin: auto; color: red;'
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            style: 'font-size: 1px; margin: auto; color: red;',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.style.cssText, 'font-size: 1px; margin: auto; color: red;')
      })

      it('patch remove style', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.style.cssText = 'font-size: 1px; margin: auto; color: red;'
        const tree = { el: parent, children: [{
          tag: 'div',
          style: 'font-size: 1px; margin: auto; color: red;',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          style: 'font-size: 1px; color: red;'
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            style: 'font-size: 1px; color: red;',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.style.cssText, 'font-size: 1px; color: red;')
      })

      it('patch remove All style', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.style.cssText = 'font-size: 1px; margin: auto; color: red;'
        const tree = { el: parent, children: [{
          tag: 'div',
          style: 'font-size: 1px; margin: auto; color: red;',
          el
        }] }
        const newTree = { children: [{
          tag: 'div'
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.style.cssText, '')
      })

      it('patch set empty style', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.style.cssText = 'font-size: 1px; margin: auto; color: red;'
        const tree = { el: parent, children: [{
          tag: 'div',
          style: 'font-size: 1px; margin: auto; color: red;',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          style: ''
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.style.cssText, '')
      })

      it('patch no change style', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.style.cssText = 'font-size: 1px; margin: auto;'
        const tree = { el: parent, children: [{
          tag: 'div',
          style: 'font-size: 1px; margin: auto;',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          style: 'font-size: 1px; margin: auto;'
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            style: 'font-size: 1px; margin: auto;',
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.style.cssText, 'font-size: 1px; margin: auto;')
      })
    })

    describe(': props', function() {
      it('patch new props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1'
          }
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            props: {
              'props-a': 'value 1'
            },
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, 'props-a: value 1;')
      })

      it('patch add props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        const tree = { el: parent, children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1'
          },
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-b': 'value 2',
            'props-c': 'value 3'
          }
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            props: {
              'props-a': 'value 1',
              'props-b': 'value 2',
              'props-c': 'value 3'
            },
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, 'props-a: value 1;props-b: value 2;props-c: value 3;')
      })

      it('patch remove props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        el.setAttribute('props-b', 'value 2')
        el.setAttribute('props-c', 'value 3')
        const tree = { el: parent, children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-b': 'value 2',
            'props-c': 'value 3'
          },
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-c': 'value 3'
          }
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            props: {
              'props-a': 'value 1',
              'props-c': 'value 3'
            },
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, 'props-a: value 1;props-c: value 3;')
      })

      it('patch remove all props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        el.setAttribute('props-b', 'value 2')
        el.setAttribute('props-c', 'value 3')
        const tree = { el: parent, children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-b': 'value 2',
            'props-c': 'value 3'
          },
          el
        }] }
        const newTree = { children: [{
          tag: 'div'
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, '')
      })

      it('patch set empty props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        el.setAttribute('props-b', 'value 2')
        el.setAttribute('props-c', 'value 3')
        const tree = { el: parent, children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-b': 'value 2',
            'props-c': 'value 3'
          },
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          props: {}
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, '')
      })

      it('patch no change props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        el.setAttribute('props-b', 'value 2')
        const tree = { el: parent, children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-b': 'value 2'
          },
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1',
            'props-b': 'value 2'
          }
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            props: {
              'props-a': 'value 1',
              'props-b': 'value 2'
            },
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, 'props-a: value 1;props-b: value 2;')
      })

      it('patch update props', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        const tree = { el: parent, children: [{
          tag: 'div',
          props: {
            'props-a': 'value 1'
          },
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          props: {
            'props-a': 'value 2'
          }
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            props: {
              'props-a': 'value 2'
            },
            el: {}
          }],
          el: {}
        })
        let output = ''
        for(const props of parent.firstChild.attributes) {
          output += props.name + ': ' + props.value + ';';
        }
        equal(output, 'props-a: value 2;')
      })
    })
    // TODO: test bools
    // TODO: test refs

    describe(': on', function() {
      it('patch new on', () => {
        const f1 = () => {}
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.setAttribute('props-a', 'value 1')
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          on: {
            click: [f1]
          }
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            on: {
              click: [null]
            },
            el: {}
          }],
          el: {}
        })
      })
      // How to test ?
    })

    describe(': children', function() {
      it('patch new text', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: ['Hello']
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: ['Hello'],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerHTML, 'Hello')
      })

      it('patch new multi texts', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: ['Hello', 'world', '!']
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: ['Hello', 'world', '!'],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerHTML, 'Helloworld!')
      })


      it('test: patch update text', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.innerHTML = 'Hello'
        const tree = { el: parent, children: [{
          tag: 'div',
          children: ['Hello'],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: ['World'],
          el
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: ['World'],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerHTML, 'World')
      })


      it('patch new Element', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'p' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'p',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.firstElementChild.tagName, 'P')
      })

      it('patch new multi Elements', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h1' },
            { tag: 'h2' },
            { tag: 'p' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'h1',
                el: {}
              },
              {
                tag: 'h2',
                el: {}
              },
              {
                tag: 'p',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.children[0].tagName, 'H1')
        equal(parent.firstChild.children[1].tagName, 'H2')
        equal(parent.firstChild.children[2].tagName, 'P')
      })

      it('patch update Element', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const p = document.createElement('p')
        el.insertAdjacentElement('beforeend', p)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'p', el: p }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'p', class: ['class-a'] }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'p',
                class: ['class-a'],
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.firstElementChild.tagName, 'P')
        equal(parent.firstChild.firstElementChild.classList.length, 1)
        equal(parent.firstChild.firstElementChild === p, true)
      })

      it('patch change Element', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const p = document.createElement('p')
        el.insertAdjacentElement('beforeend', p)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'p', el: p }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h1' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'h1',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.firstElementChild.tagName, 'H1')
        equal(parent.firstChild.firstElementChild === p, false)
      })

      it('patch new Number', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            0
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              0
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.childElementCount, 0)
      })

      it('patch new multi Numbers', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            100, 1, 0
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              100, 1, 0
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.childElementCount, 0)
      })

      it('patch new cross Nodes', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const tree = { el: parent, children: [{
          tag: 'div',
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            'Hello',
            { tag: 'br' },
            'world',
            '!',
            10,
            { tag: 'span' },
            { tag: 'a' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              'Hello',
              {
                tag: 'br',
                el: {}
              },
              'world',
              '!',
              10,
              {
                tag: 'span',
                el: {}
              },
              {
                tag: 'a',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerText, 'Helloworld!')
        equal(parent.firstChild.children[0].tagName, 'BR')
        equal(parent.firstChild.children[1].tagName, 'SPAN')
        equal(parent.firstChild.children[2].tagName, 'A')
      })

      it('patch change text to Element', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.insertAdjacentText('beforeend', 'Hello')
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            'Hello'
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'p' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'p',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.firstElementChild.tagName, 'P')
        equal(parent.firstChild.childNodes.length, 1)
      })

      it('patch change Element to text', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const p = document.createElement('p')
        el.insertAdjacentElement('beforeend', p)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'p', el: p }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            'Hello'
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              'Hello'
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerText, 'Hello')
        equal(parent.firstChild.childNodes.length, 1)
      })

      it('patch add text to texts', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.insertAdjacentText('beforeend', 'Hello')
        el.insertAdjacentText('beforeend', '!')
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            'Hello',
            '!'
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            'Hello',
            'World',
            '!'
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              'Hello',
              'World',
              '!'
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerHTML, 'HelloWorld!')
        equal(parent.firstChild.childNodes.length, 3)
      })

      it('patch add text to Elements', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const h1 = document.createElement('h1')
        el.insertAdjacentElement('beforeend', h1)
        const h2 = document.createElement('h2')
        el.insertAdjacentElement('beforeend', h2)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'h1', el: h1 },
            { tag: 'h2', el: h2 }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h1' },
            'World',
            { tag: 'h2' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'h1',
                el: {}
              },
              'World',
              {
                tag: 'h2',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerText, 'World')
        equal(parent.firstChild.childNodes.length, 3)
        equal(parent.firstChild.childNodes[0].tagName, 'H1')
        equal(parent.firstChild.childNodes[2].tagName, 'H2')
      })

      it('patch add Element to texts', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.insertAdjacentText('beforeend', 'Hello')
        el.insertAdjacentText('beforeend', '!')
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            'Hello',
            '!'
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            'Hello',
            { tag: 'span' },
            '!'
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              'Hello',
              {
                tag: 'span',
                el: {}
              },
              '!'
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerText, 'Hello!')
        equal(parent.firstChild.childNodes.length, 3)
        equal(parent.firstChild.childNodes[1].tagName, 'SPAN')
      })

      it('patch add Element to Elements', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const h1 = document.createElement('h1')
        el.insertAdjacentElement('beforeend', h1)
        const h2 = document.createElement('h2')
        el.insertAdjacentElement('beforeend', h2)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'h1', el: h1 },
            { tag: 'h2', el: h2 }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h1' },
            { tag: 'p' },
            { tag: 'h2' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'h1',
                el: {}
              },
              {
                tag: 'p',
                el: {}
              },
              {
                tag: 'h2',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.childNodes[0].tagName, 'H1')
        equal(parent.firstChild.childNodes[1].tagName, 'P')
        equal(parent.firstChild.childNodes[2].tagName, 'H2')
      })

      it('patch add Elements to Elements', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const h1 = document.createElement('h1')
        el.insertAdjacentElement('beforeend', h1)
        const h2 = document.createElement('h2')
        el.insertAdjacentElement('beforeend', h2)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'h1', el: h1 },
            { tag: 'h2', el: h2 }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h3' },
            { tag: 'h4' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              {
                tag: 'h3',
                el: {}
              },
              {
                tag: 'h4',
                el: {}
              }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.childNodes[0].tagName, 'H3')
        equal(parent.firstChild.childNodes[1].tagName, 'H4')
      })

      it('patch remove text', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        el.insertAdjacentText('beforeend', 'Hello')
        el.insertAdjacentText('beforeend', 'World')
        el.insertAdjacentText('beforeend', '!')
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            'Hello',
            'World',
            '!'
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            'Hello',
            '!'
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              'Hello',
              '!'
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerHTML, 'Hello!')
        equal(parent.firstChild.childNodes.length, 2)
      })

      it('patch remove Element', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const h1 = document.createElement('h1')
        el.insertAdjacentElement('beforeend', h1)
        const p = document.createElement('p')
        el.insertAdjacentElement('beforeend', p)
        const h2 = document.createElement('h2')
        el.insertAdjacentElement('beforeend', h2)
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'h1', el: h1 },
            { tag: 'p', el: p },
            { tag: 'h2', el: h2 }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h1' },
            { tag: 'h2' }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              { tag: 'h1', el: {} },
              { tag: 'h2', el: {} }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.childNodes[0].tagName, 'H1')
        equal(parent.firstChild.childNodes[1].tagName, 'H2')
      })

      it('patch use key', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const h1 = document.createElement('h1')
        el.insertAdjacentElement('beforeend', h1)
        const h2 = document.createElement('h2')
        el.insertAdjacentElement('beforeend', h2)
        const h1key = {}
        const h2key = {}
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'h1', el: h1, key: h1key },
            { tag: 'h2', el: h2, key: h2key }
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            { tag: 'h2', key: h2key },
            { tag: 'h1', key: h1key, class: ['class-a'] }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              { tag: 'h2', key: {}, el: {} },
              { tag: 'h1', key: {}, class: ['class-a'], el: {} }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.childNodes[0].tagName, 'H2')
        equal(parent.firstChild.childNodes[1].tagName, 'H1')
        equal(parent.firstChild.lastElementChild.classList.length, 1)
        equal(parent.firstChild.childNodes[0] === h2, true)
        equal(parent.firstChild.childNodes[1] === h1, true)
      })

      it('patch use key and number', () => {
        const parent = document.createElement('div')
        const el = document.createElement('div')
        parent.appendChild(el)
        const p = document.createElement('p')
        el.insertAdjacentElement('beforeend', p)
        const h1 = document.createElement('h1')
        el.insertAdjacentElement('beforeend', h1)
        const h2 = document.createElement('h2')
        el.insertAdjacentElement('beforeend', h2)
        const h1key = {}
        const h2key = {}
        const tree = { el: parent, children: [{
          tag: 'div',
          children: [
            { tag: 'p', el: p },
            0,
            { tag: 'h1', el: h1, key: h1key },
            { tag: 'h2', el: h2, key: h2key },
            1
          ],
          el
        }] }
        const newTree = { children: [{
          tag: 'div',
          children: [
            'Hello',
            0,
            { tag: 'h2', key: h2key },
            1,
            { tag: 'h1', key: h1key }
          ]
        }] }
        patch(tree, newTree)
        equal(tree, {
          children: [{
            tag: 'div',
            children: [
              'Hello',
              0,
              { tag: 'h2', key: {}, el: {} },
              1,
              { tag: 'h1', key: {}, el: {} }
            ],
            el: {}
          }],
          el: {}
        })
        equal(parent.firstChild.innerText, 'Hello')
        equal(parent.firstChild.childNodes[1] === h2, true)
        equal(parent.firstChild.childNodes[2] !== h1, true)
      })
    })
    // TODO: test real element
  })
})

describe('Template Engine', function() {
  describe('Script parser', function() {
    const stack = {
      x: 1,
      y: 10,
      s: 'o',
      h: { x: 2, y: { x: 3 }, z: [7] },
      a: [4, 5, [6], { x: 8 }],
      text: 'x',
      f: () => 5,
      add: (a, b) => a + b
    }

    it('expression: number', () => {
      equal(evaluate(expression('50.5'), [stack]), 50.5)
    })

    it('expression: true', () => {
      equal(evaluate(expression('true'), [stack]), true)
    })

    it('expression: string: single', () => {
      equal(evaluate(expression('\'string\''), [stack]), 'string')
    })

    it('expression: string: double', () => {
      equal(evaluate(expression('"string"'), [stack]), 'string')
    })

    it('expression: string tenplate: string only', () => {
      equal(evaluate(expression('`string`'), [stack]), 'string')
    })

    it('expression: string tenplate: has expression', () => {
      equal(evaluate(expression('`Hello ${text}!`'), [stack]), 'Hello x!')
    })

    it('expression: string escape: normal char', () => {
      equal(evaluate(expression("'\\a'"), [stack]), "a")
    })

    it('expression: string escape: special char', () => {
      equal(evaluate(expression("'\\n\\r\\v\\t\\b\\f'"), [stack]), "\n\r\v\t\b\f")
    })

    it('expression: string escape: \\', () => {
      equal(evaluate(expression("'\\\\'"), [stack]), "\\")
    })

    it('expression: string escape: single in single', () => {
      equal(evaluate(expression("'\\''"), [stack]), "'")
    })

    it('expression: string escape: double in double', () => {
      equal(evaluate(expression('"\\""'), [stack]), '"')
    })

    it('expression: string escape: \\uXXXX', () => {
      equal(evaluate(expression("'\\u0006\\u11aa'"), [stack]), "\u0006\u11aa")
    })

    it('expression: string escape: \\u{X...XXXXXX}', () => {
      equal(evaluate(expression("'\\u{6}\\u{109abF}'"), [stack]), "\u{6}\u{109abF}")
    })

    it('expression: string escape: \\xXX', () => {
      equal(evaluate(expression("'\\x0c\\x9F'"), [stack]), "\x0c\x9F")
    })

    it('expression: word', () => {
      equal(evaluate(expression('x'), [stack]), 1)
      equal(evaluate(expression('text'), [stack]), 'x')
    })

    it('expression: array [a, b]', () => {
      equal(evaluate(expression('[2, 1 + 2, x]'), [stack]), [2, 3, 1])
    })

    it('expression: array []', () => {
      equal(evaluate(expression('[]'), [stack]), [])
    })

    it('expression: array [...a]', () => {
      equal(evaluate(expression('[2, ...a[2]]'), [stack]), [2, 6])
    })

    it('expression: object { x: "", [x]: ""}', () => {
      equal(evaluate(expression('{ y: "x", [s]: 1 + x, ["t"]: "" }'), [stack]), { y: "x", o: 2, t: '' })
    })

    it('expression: object {}', () => {
      equal(evaluate(expression('{}'), [stack]), {})
    })

    it('expression: object { x }', () => {
      equal(evaluate(expression('{ x }'), [stack]), { x: 1 })
    })

    it('expression: object { "x": "" }', () => {
      equal(evaluate(expression('{ "y": x, \'c-d\': x }'), [stack]), { y: 1, "c-d": 1 })
    })

    it('expression: object { ...x }', () => {
      equal(evaluate(expression('{ y: "x", ...a[3]}'), [stack]), { y: "x", x: 8 })
    })

    it('expression: hash h.x', () => {
      equal(evaluate(expression('h.x'), [stack]), 2)
    })

    it('expression: hash h[text]', () => {
      equal(evaluate(expression('h[text]'), [stack]), 2)
    })

    it('expression: hash h.y.x', () => {
      equal(evaluate(expression('h.y.x'), [stack]), 3)
    })

    it('expression: hash h.y?.x', () => {
      equal(evaluate(expression('h.y?.x'), [stack]), 3)
      equal(evaluate(expression('h.y?.y'), [stack]), undefined)
      equal(evaluate(expression('h.t?.x'), [stack]), undefined)
    })

    it('expression: function f()', () => {
      equal(evaluate(expression('f()'), [stack]), 5)
    })

    it('expression: function f(a, b)', () => {
      equal(evaluate(expression('add(4, 7)'), [stack]), 11)
    })

    it('expression: function f(...a)', () => {
      equal(evaluate(expression('add(...a)'), [stack]), 9)
    })

    it('expression: hash a[0]', () => {
      equal(evaluate(expression('a[0]'), [stack]), 4)
    })

    it('expression: hash a[2][0]', () => {
      equal(evaluate(expression('a[2][0]'), [stack]), 6)
    })

    it('expression: hash a[2-1]', () => {
      equal(evaluate(expression('a[2-1]'), [stack]), 5)
    })

    it('expression: hash h.z[0]', () => {
      equal(evaluate(expression('h.z[0]'), [stack]), 7)
    })

    it('expression: hash a[3].x', () => {
      equal(evaluate(expression('a[3].x'), [stack]), 8)
    })

    it('expression: unary oparate +', () => {
      equal(evaluate(expression('+ 1'), [stack]), 1)
    })

    it('expression: unary oparate -', () => {
      equal(evaluate(expression('- 1'), [stack]), -1)
    })

    it('expression: unary oparate void', () => {
      equal(evaluate(expression('void 0'), [stack]), undefined)
      equal(evaluate(expression('void(0)'), [stack]), undefined)
    })

    it('expression: unary oparate typeof', () => {
      equal(evaluate(expression('typeof 1'), [stack]), 'number')
    })

    it('expression: unary oparate ~', () => {
      equal(evaluate(expression('~ 1'), [stack]), -2)
    })

    it('expression: unary oparate !', () => {
      equal(evaluate(expression('! 1'), [stack]), false)
    })

    it('expression: binary oparate +', () => {
      equal(evaluate(expression('x + 1'), [stack]), 2)
    })

    it('expression: binary oparate -', () => {
      equal(evaluate(expression('x - 2'), [stack]), -1)
    })

    it('expression: binary oparate /', () => {
      equal(evaluate(expression('x / 2'), [stack]), 0.5)
    })

    it('expression: binary oparate *', () => {
      equal(evaluate(expression('x * 2'), [stack]), 2)
    })

    it('expression: binary oparate %', () => {
      equal(evaluate(expression('y % 7'), [stack]), 3)
    })

    it('expression: binary oparate **', () => {
      equal(evaluate(expression('y ** 2'), [stack]), 100)
    })

    it('expression: binary oparate in', () => {
      equal(evaluate(expression("'x' in h"), [stack]), true)
      equal(evaluate(expression("'ttt' in h.y"), [stack]), false)
    })

    it('expression: oparate ==', () => {
      equal(evaluate(expression('x == 1'), [stack]), true)
    })

    it('expression: oparate !=', () => {
      equal(evaluate(expression('x != 1'), [stack]), false)
    })

    it('expression: oparate ===', () => {
      equal(evaluate(expression('x === 1'), [stack]), true)
    })

    it('expression: oparate !==', () => {
      equal(evaluate(expression('x !== 1'), [stack]), false)
    })

    it('expression: oparate <', () => {
      equal(evaluate(expression('x < 1'), [stack]), false)
      equal(evaluate(expression('x < 2'), [stack]), true)
    })

    it('expression: oparate <=', () => {
      equal(evaluate(expression('x <= 1'), [stack]), true)
    })

    it('expression: oparate >', () => {
      equal(evaluate(expression('x > 1'), [stack]), false)
      equal(evaluate(expression('x > -1'), [stack]), true)
    })

    it('expression: oparate >=', () => {
      equal(evaluate(expression('x >= 1'), [stack]), true)
    })

    it('expression: oparate ||', () => {
      equal(evaluate(expression('true || false'), [stack]), true)
    })

    it('expression: oparate &&', () => {
      equal(evaluate(expression('true && false'), [stack]), false)
    })

    it('expression: oparate ?:', () => {
      equal(evaluate(expression('1?2:3'), [stack]), 2)
      equal(evaluate(expression('0?1:2?3:4'), [stack]), 3)
    })

    it('expression: assign =', () => {
      const data = { a: 0, b: 0 }
      evaluate(expression('a = 1'), [stack, data])
      evaluate(expression('b = x'), [stack, data])
      equal(data.a, 1)
      equal(data.b, 1)
    })

    it('expression: assign +=', () => {
      const data = { a: 1 }
      evaluate(expression('a += 4'), [stack, data])
      equal(data.a, 5)
    })

    it('expression: assign -=', () => {
      const data = { a: 1 }
      evaluate(expression('a -= 4'), [stack, data])
      equal(data.a, -3)
    })

    it('expression: assign *=', () => {
      const data = { a: 2 }
      evaluate(expression('a *= 4'), [stack, data])
      equal(data.a, 8)
    })

    it('expression: assign **=', () => {
      const data = { a: 2 }
      evaluate(expression('a **= 4'), [stack, data])
      equal(data.a, 16)
    })

    it('expression: assign /=', () => {
      const data = { a: 10 }
      evaluate(expression('a /= 4'), [stack, data])
      equal(data.a, 2.5)
    })

    it('expression: assign %=', () => {
      const data = { a: 10 }
      evaluate(expression('a %= 4'), [stack, data])
      equal(data.a, 2)
    })

    it('expression: assign <<=', () => {
      const data = { a: 2 }
      evaluate(expression('a <<= 4'), [stack, data])
      equal(data.a, 32)
    })

    it('expression: assign >>=', () => {
      const data = { a: -5 }
      evaluate(expression('a >>= 2'), [stack, data])
      equal(data.a, -2)
    })

    it('expression: assign >>>=', () => {
      const data = { a: -5 }
      evaluate(expression('a >>>= 2'), [stack, data])
      equal(data.a, 1073741822)
    })

    it('expression: assign &=', () => {
      const data = { a: 5 }
      evaluate(expression('a &= 6'), [stack, data])
      equal(data.a, 4)
    })

    it('expression: assign ^=', () => {
      const data = { a: 5 }
      evaluate(expression('a ^= 6'), [stack, data])
      equal(data.a, 3)
    })

    it('expression: assign |=', () => {
      const data = { a: 5 }
      evaluate(expression('a |= 6'), [stack, data])
      equal(data.a, 7)
    })

    it('expression: assign &&=', () => {
      const data = { a: 10, b: 0 }
      evaluate(expression('a &&= 4'), [stack, data])
      evaluate(expression('b &&= 4'), [stack, data])
      equal(data.a, 4)
      equal(data.b, 0)
    })

    it('expression: assign ||=', () => {
      const data = { a: 10, b: 0 }
      evaluate(expression('a ||= 4'), [stack, data])
      evaluate(expression('b ||= 4'), [stack, data])
      equal(data.a, 10)
      equal(data.b, 4)
    })

    it('expression: assign ??=', () => {
      const data = { a: 10, b: 0, c: undefined, d: null }
      evaluate(expression('a ??= 4'), [stack, data])
      evaluate(expression('b ??= 4'), [stack, data])
      evaluate(expression('c ??= 4'), [stack, data])
      evaluate(expression('d ??= 4'), [stack, data])
      equal(data.a, 10)
      equal(data.b, 0)
      equal(data.c, 4)
      equal(data.d, 4)
    })

    // TODO: test destructuring assignment
    // TODO: test new operator
    // TODO: test delete operator
    // TODO: test camma operator
  })

  describe('parse()', function() {
    describe(': overload', function() {
      it('parse string', () => {
        const template = parse('<style></style><p></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "style",
              type: "element"
            },
            {
              tag: "p",
              type: "element"
            }
          ]
        })
      })
    })

    describe(': text', function() {
      it('parse Text Node', () => {
        const template = parse('Hello beako!')
        equal(template, {
          type: 'tree',
          children: [
            "Hello beako!"
          ]
        })
      })

      it('parse unicode', () => {
        const template = parse('مرحبا ベア子😆')
        equal(template, {
          type: 'tree',
          children: [
            "مرحبا ベア子😆"
          ]
        })
      })

      it('parse a variable in Text Node', () => {
        const template = parse('Hello {{ name }}!')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "flat",
              values: [
                "Hello ",
                {
                  type: "draw",
                  value: {
                    type: "get",
                    value: {
                      type: "variable",
                      name: "name"
                    }
                  }
                },
                "!"
              ]
            }
          ]
        })
      })
      it('parse Text Node in element', () => {
        const template = parse('<p>Hello beako!</p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              children: [
                "Hello beako!"
              ]
            }
          ]
        })
      })
      it('parse a element in Text Node', () => {
        const template = parse('Hello <span>beako</span>!')
        equal(template, {
          type: 'tree',
          children: [
            "Hello ",
            {
              tag: "span",
              type: "element",
              children: [
                "beako"
              ]
            },
            "!"
          ]
        })
      })
    })

    describe(': style', function() {
      it('parse: style', () => {
        const template = parse('<p style="color: red"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              style: "color: red"
            }
          ]
        })
      })

      it('parse: add style only', () => {
        const template = parse(`<p style:="'color: red'"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              style: {
                type: "join",
                separator: ";",
                values: [
                  {
                    type: "literal",
                    value: "color: red"
                  }
                ]
              }
            }
          ]
        })
      })

      it('parse: add style', () => {
        const template = parse(`<p style="color: red" style:="\`margin-top: \${x}px\`"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              style: {
                type: "join",
                separator: ";",
                values: [
                  "color: red",
                  {
                    type: "join",
                    separator: "",
                    values: [
                      "margin-top: ",
                      {
                        type: "get",
                        value: {
                          type: "variable",
                          name: "x"
                        }
                      },
                      "px"
                    ]
                  }
                ]
              }
            }
          ]
        })
      })

    //   it('parse: add styles', () => {
    //     const template = parse(`<p style="color: red" style+1="'margin-top: 5px'" style+2="'margin: 0 auto'"></p>`)
    //     equal(template, {
    //       type: 'tree',
    //       children: [
    //         {
    //           tag: "p",
    //           type: "element",
    //           style: {
    //             type: "join",
    //             separator: ";",
    //             values: [
    //               "color: red",
    //               {
    //                 type: "literal",
    //                 value: "margin-top: 5px"
    //               },
    //               {
    //                 type: "literal",
    //                 value: "margin: 0 auto"
    //               }
    //             ]
    //           }
    //         }
    //       ]
    //     })
    //   })
    })

    describe(': props', function() {
      it('parse: props', () => {
        const template = parse('<p id="beako"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              props: {
                id: "beako"
              }
            }
          ]
        })
      })

      it('parse: assign props variable', () => {
        const template = parse(`<p id:="id"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              props: {
                id: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "id"
                  }
                }
              }
            }
          ]
        })
      })

      it('parse: boolean props variable', () => {
        const template = parse(`<p id&="id"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              bools: {
                id: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "id"
                  }
                }
              }
            }
          ]
        })
      })

      it('parse: assign props already variable', () => {
        const template = parse(`<p id="id" id:="id"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              props: {
                id: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "id"
                  }
                }
              }
            }
          ]
        })
      })

      it('parse: boolean props override props', () => {
        const template = parse(`<p id="id" id&="id"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              bools: {
                id: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "id"
                  }
                }
              }
            }
          ]
        })
      })

      it('parse: boolean props override assign props', () => {
        const template = parse(`<p id:="id" id&="id"></p>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              bools: {
                id: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "id"
                  }
                }
              }
            }
          ]
        })
      })

      it('parse: multi props', () => {
        const template = parse('<p id:="id" slot="my-slot"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              props: {
                id: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "id"
                  }
                },
                slot: "my-slot"
              }
            }
          ]
        })
      })
    })

    describe(': on', function() {
      it('parse: on', () => {
        const template = parse('<p onclick="value"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              on: {
                click: [
                  {
                    type: 'handler',
                    value: {
                      type: "get",
                      value: {
                        type: "variable",
                        name: "value"
                      }
                    }
                  }
                ]
              }
            }
          ]
        })
      })
      it('parse: add ons', () => {
        const template = parse('<p onclick="value" onclick="value2"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              tag: "p",
              type: "element",
              on: {
                click: [
                  {
                    type: 'handler',
                    value: {
                      type: "get",
                      value: {
                        type: "variable",
                        name: "value"
                      }
                    }
                  },
                  {
                    type: 'handler',
                    value: {
                      type: "get",
                      value: {
                        type: "variable",
                        name: "value2"
                      }
                    }
                  }
                ]
              }
            }
          ]
        })
      })
      // it('parse: add reverse ons', () => {
      //   const template = parse('<p onclick+="value2" onclick="value" onclick+1="value3"></p>')
      //   equal(template, {
      //     type: 'tree',
      //     children: [
      //       {
      //         tag: "p",
      //         type: "element",
      //         on: {
      //           click: [
      //             {
      //               type: 'handler',
      //               value: {
      //                 type: "get",
      //                 value: {
      //                   type: "variable",
      //                   name: "value"
      //                 }
      //               }
      //             },
      //             {
      //               type: 'handler',
      //               value: {
      //                 type: "get",
      //                 value: {
      //                   type: "variable",
      //                   name: "value2"
      //                 }
      //               }
      //             },
      //             {
      //               type: 'handler',
      //               value: {
      //                 type: "get",
      //                 value: {
      //                   type: "variable",
      //                   name: "value3"
      //                 }
      //               }
      //             }
      //           ]
      //         }
      //       }
      //     ]
      //   })
      // })
    })

    describe(': @if', function() {
      it('parse: @if', () => {
        const template = parse('<p @if="isActive"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                tag: "p",
                type: "element"
              }
            }
          ]
        })
      })
      it('parse: @if @else', () => {
        const template = parse('<p @if="isActive"></p><div @else></div>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                tag: "p",
                type: "element"
              },
              falsy: {
                tag: "div",
                type: "element"
              },
            }
          ]
        })
      })

      it('parse: @if @else has space', () => {
        const template = parse(`<p @if="isActive"></p>
          <div @else></div>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                tag: "p",
                type: "element"
              },
              falsy: {
                tag: "div",
                type: "element"
              },
            }
          ]
        })
      })
      
      it('parse: @if @else has not space', () => {
        const template = parse(`<p @if="isActive"></p>.<div @else></div>`)
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                tag: "p",
                type: "element"
              }
            },
            ".",
            {
              tag: "div",
              type: "element"
            }
          ]
        })
      })

      it('parse: @if @else chain', () => {
        const template = parse('<p @if="isActive"></p><div @else @if="isNext"></div><h2 @else></h2>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                tag: "p",
                type: "element"
              },
              falsy: {
                type: "if",
                condition: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "isNext"
                  }
                },
                truthy: {
                  tag: "div",
                  type: "element"
                },
                falsy: {
                  tag: "h2",
                  type: "element"
                }
              },
            }
          ]
        })
      })
    })

    describe(': @for', function() {
      it('parse: @for', () => {
        const template = parse('<p @for="array"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "for",
              array: {
                type: "get",
                value: {
                  type: "variable",
                  name: "array"
                }
              },
              value: {
                tag: "p",
                type: "element"
              }
            }
          ]
        })
      })
      it('parse: @for @each', () => {
        const template = parse('<p @for="array" @each="value"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "for",
              array: {
                type: "get",
                value: {
                  type: "variable",
                  name: "array"
                }
              },
              value: {
                tag: "p",
                type: "element"
              },
              each: "value"
            }
          ]
        })
      })
    })

    describe(': <group>', function() {
      it('parse: group', () => {
        const template = parse('<group>Hello <span>beako</span></group>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "group",
              children: [
                "Hello ",
                {
                  tag: "span",
                  type: "element",
                  children: ["beako"]
                }
              ]
            }
          ]
        })
      })
      it('parse: group has props', () => {
        const template = parse('<group title="name" @as="header">Hello</group>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "group",
              props: {
                ["@as"]: "header"
              },
              children: ["Hello"]
            }
          ]
        })
      })
    })

    describe(': combinate', function() {
      it('parse: @if and @for', () => {
        const template = parse('<p @for="array" @if="isActive"></p>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "for",
              array: {
                type: "get",
                value: {
                  type: "variable",
                  name: "array"
                }
              },
              value: {
                type: "if",
                condition: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "isActive"
                  }
                },
                truthy: {
                  tag: "p",
                  type: "element"
                }
              }
            }
          ]
        })
      })
      it('parse: @if, @else and @for', () => {
        const template = parse('<p @for="array" @if="isActive"></p><div @else></div>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "for",
              array: {
                type: "get",
                value: {
                  type: "variable",
                  name: "array"
                }
              },
              value: {
                type: "if",
                condition: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "isActive"
                  }
                },
                truthy: {
                  tag: "p",
                  type: "element"
                },
                falsy: {
                  tag: "div",
                  type: "element"
                }
              }
            }
          ]
        })
      })
      it('parse: @if and <group>', () => {
        const template = parse('<group @if="isActive">Hello</group>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                type: "group",
                children: ["Hello"]
              }
            }
          ]
        })
      })
      it('parse: @if, @else and <group>', () => {
        const template = parse('<p @if="isActive"></p><group @else>Hello</group>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "if",
              condition: {
                type: "get",
                value: {
                  type: "variable",
                  name: "isActive"
                }
              },
              truthy: {
                tag: "p",
                type: "element"
              },
              falsy: {
                type: "group",
                children: ["Hello"]
              }
            }
          ]
        })
      })
      it('parse: @for and <group>', () => {
        const template = parse('<group @for="array">Hello</group>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "for",
              array: {
                type: "get",
                value: {
                  type: "variable",
                  name: "array"
                }
              },
              value: {
                type: "group",
                children: ["Hello"]
              }
            }
          ]
        })
      })
      it('parse: @if, @for and <group>', () => {
        const template = parse('<group @for="array" @if="isActive">Hello</group>')
        equal(template, {
          type: 'tree',
          children: [
            {
              type: "for",
              array: {
                type: "get",
                value: {
                  type: "variable",
                  name: "array"
                }
              },
              value: {
                type: "if",
                condition: {
                  type: "get",
                  value: {
                    type: "variable",
                    name: "isActive"
                  }
                },
                truthy: {
                  type: "group",
                  children: ["Hello"]
                }
              }
            }
          ]
        })
      })
    })
    // TODO: test loop parent
  })

  describe('evaluate()', function() {
    describe(': text', function() {
      it('evaluate Text Node', () => {
        const tree = evaluate(parse('Hello beako!'), [])
        equal(tree, {
          children: [
            "Hello beako!"
          ]
        })
      })

      it('evaluate unicode', () => {
        const tree = evaluate(parse('مرحبا ベア子😆'), [])
        equal(tree, {
          children: [
            "مرحبا ベア子😆"
          ]
        })
      })

      it('evaluate a variable in Text Node', () => {
        const tree = evaluate(parse('Hello {{ name }}!'), [{ name: 'beako' }])
        equal(tree, {
          children: [
            "Hello beako!"
          ]
        })
      })

      it('evaluate Text Node in element', () => {
        const tree = evaluate(parse('<p>Hello beako!</p>'))
        equal(tree, {
          children: [
            {
              tag: "p",
              children: [
                "Hello beako!"
              ]
            }
          ]
        })
      })
      it('evaluate a element in Text Node', () => {
        const tree = evaluate(parse('Hello <span>beako</span>!'))
        equal(tree, {
          children: [
            "Hello ",
            {
              tag: "span",
              children: [
                "beako"
              ]
            },
            "!"
          ]
        })
      })
    })

    describe(': style', function() {
      it('evaluate: style', () => {
        const tree = evaluate(parse('<p style="color: red"></p>'))
        equal(tree, {
          children: [
            {
              tag: "p",
              style: "color: red"
            }
          ]
        })
      })

      it('evaluate: add style only', () => {
        const tree = evaluate(parse(`<p style:="'color: red'"></p>`))
        equal(tree, {
          children: [
            {
              tag: "p",
              style: "color: red"
            }
          ]
        })
      })

      it('evaluate: add style', () => {
        const tree = evaluate(parse(`<p style="color: red" style:="\`margin-top: \${x}px\`"></p>`), [{ x: 10 }])
        equal(tree, {
          children: [
            {
              tag: "p",
              style: "color: red;margin-top: 10px"
            }
          ]
        })
      })

      // it('evaluate: add styles', () => {
      //   const tree = evaluate(parse(`<p style="color: red" style+1="'margin-top: 5px'" style+2="'margin: 0 auto'"></p>`))
      //   equal(tree, {
      //     children: [
      //       {
      //         tag: "p",
      //         style: "color: red;margin-top: 5px;margin: 0 auto"
      //       }
      //     ]
      //   })
      // })
    })

    describe(': props', function() {
      it('evaluate: props', () => {
        const tree = evaluate(parse('<p id="beako"></p>'))
        equal(tree, {
          children: [
            {
              tag: "p",
              props: {
                id: "beako"
              }
            }
          ]
        })
      })

      it('evaluate: add props variable', () => {
        const tree = evaluate(parse(`<p id:="id"></p>`), [{ id: 'beako' }])
        equal(tree, {
          children: [
            {
              tag: "p",
              props: {
                id: "beako"
              }
            }
          ]
        })
      })

      it('evaluate: multi props is not string', () => {
        const tree = evaluate(parse('<p value:="value"></p>'), [{ value: 10 }])
        equal(tree, {
          children: [
            {
              tag: "p",
              props: {
                value: 10
              }
            }
          ]
        })
      })

      it('evaluate: truthy props variable', () => {
        const tree = evaluate(parse(`<p id&="1"></p>`))
        equal(tree, {
          children: [
            {
              tag: "p",
              props: {
                id: 1
              }
            }
          ]
        })
      })

      it('evaluate: falsy props variable', () => {
        const tree = evaluate(parse(`<p id&="0"></p>`))
        equal(tree, {
          children: [
            {
              tag: "p"
            }
          ]
        })
      })

      it('evaluate: multi props', () => {
        const tree = evaluate(parse('<p id:="id" slot="my-slot" value:="value"></p>'), [{ id: 'beako', value: 10 }])
        equal(tree, {
          children: [
            {
              tag: "p",
              props: {
                id: "beako",
                slot: "my-slot",
                value: 10
              }
            }
          ]
        })
      })
    })

    describe(': @if', function() {
      it('evaluate: @if is true', () => {
        const tree = evaluate(parse('<p @if="isActive"></p>'), [{ isActive: true }])
        equal(tree, {
          children: [{ tag: "p" }]
        })
      })
      it('evaluate: @if is false', () => {
        const tree = evaluate(parse('<p @if="isActive"></p>'), [{ isActive: false }])
        equal(tree, {})
      })
      it('evaluate: @if is true @else', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><div @else></div>'), [{ isActive: true }])
        equal(tree, {
          children: [{ tag: "p" }]
        })
      })
      it('evaluate: @if is false @else', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><div @else></div>'), [{ isActive: false }])
        equal(tree, {
          children: [{ tag: "div" }]
        })
      })
      it('evaluate: @if @else chain / true true', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><div @else @if="isNext"></div><h2 @else></h2>'), [{ isActive: true, isNext: true }])
        equal(tree, {
          children: [{ tag: "p" }]
        })
      })
      it('evaluate: @if @else chain / false true', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><div @else @if="isNext"></div><h2 @else></h2>'), [{ isActive: false, isNext: true }])
        equal(tree, {
          children: [{ tag: "div" }]
        })
      })
      it('evaluate: @if @else chain / false false', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><div @else @if="isNext"></div><h2 @else></h2>'), [{ isActive: false, isNext: false }])
        equal(tree, {
          children: [{ tag: "h2" }]
        })
      })
      it('evaluate: @if with text is false', () => {
        const tree = evaluate(parse('text<span @if="isActive"></span> text'), [{ isActive: false }])
        equal(tree, {
          children: ['text', 2, ' text']
        })
      })
      it('evaluate: @if with text is true', () => {
        const tree = evaluate(parse('text<span @if="isActive"></span> text'), [{ isActive: true }])
        equal(tree, {
          children: ['text', { tag: "span" }, 2, ' text']
        })
      })
      it('evaluate: @if @else with text is false', () => {
        const tree = evaluate(parse('text<span @if="isActive"></span> <b @else></b> text'), [{ isActive: false }])
        equal(tree, {
          children: ['text', { tag: "b" }, 2, ' text']
        })
      })
      it('evaluate: @if @else with text is true', () => {
        const tree = evaluate(parse('text<span @if="isActive"></span> <b @else></b> text'), [{ isActive: true }])
        equal(tree, {
          children: ['text', { tag: "span" }, 2, ' text']
        })
      })
    })

    describe(': @for', function() {
      it('evaluate: @for array', () => {
        const tree = evaluate(parse('<p @for="array"></p>'), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            { tag: "p" },
            { tag: "p" },
            { tag: "p" }
          ]
        })
      })
      it('evaluate: @for array empty', () => {
        const tree = evaluate(parse('<p @for="array"></p>'), [{ array: [] }])
        equal(tree, {})
      })
      it('evaluate: @for array: @each', () => {
        const tree = evaluate(parse('<p @for="array" @each="value">{{ value }}</p>'), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x"]
            },
            {
              tag: "p",
              children: ["y"]
            },
            {
              tag: "p",
              children: ["z"]
            }
          ]
        })
      })
      it('evaluate: @for array: loop', () => {
        const tree = evaluate(parse('<p @for="array">{{ loop.key }}|{{ loop.value }}|{{ loop.index }}|{{ loop.size }}|{{ loop.isFirst }}|{{ loop.isLast }}</p>'), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["0|x|0|3|true|false"]
            },
            {
              tag: "p",
              children: ["1|y|1|3|false|false"]
            },
            {
              tag: "p",
              children: ["2|z|2|3|false|true"]
            }
          ]
        })
      })
      it('evaluate: @for object: @each', () => {
        const tree = evaluate(parse('<p @for="array" @each="value">{{ value }}</p>'), [{ array: { x: 'xx', y: 'yy', z: 'zz' } }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["xx"]
            },
            {
              tag: "p",
              children: ["yy"]
            },
            {
              tag: "p",
              children: ["zz"]
            }
          ]
        })
      })
      it('evaluate: @for object: loop', () => {
        const tree = evaluate(parse('<p @for="array">{{ loop.key }}|{{ loop.value }}|{{ loop.index }}|{{ loop.size }}|{{ loop.isFirst }}|{{ loop.isLast }}</p>'), [{ array: { x: 'xx', y: 'yy', z: 'zz' } }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x|xx|0|3|true|false"]
            },
            {
              tag: "p",
              children: ["y|yy|1|3|false|false"]
            },
            {
              tag: "p",
              children: ["z|zz|2|3|false|true"]
            }
          ]
        })
      })
      it('evaluate: @for Set: @each', () => {
        const tree = evaluate(parse('<p @for="array" @each="value">{{ value }}</p>'), [{ array: new Set(['x', 'y', 'z']) }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x"]
            },
            {
              tag: "p",
              children: ["y"]
            },
            {
              tag: "p",
              children: ["z"]
            }
          ]
        })
      })
      it('evaluate: @for Set: loop', () => {
        const tree = evaluate(parse('<p @for="array">{{ loop.key }}|{{ loop.value }}|{{ loop.index }}|{{ loop.size }}|{{ loop.isFirst }}|{{ loop.isLast }}</p>'), [{ array: new Set(['x', 'y', 'z']) }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x|x|0|3|true|false"]
            },
            {
              tag: "p",
              children: ["y|y|1|3|false|false"]
            },
            {
              tag: "p",
              children: ["z|z|2|3|false|true"]
            }
          ]
        })
      })
      it('evaluate: @for Map: @each', () => {
        const tree = evaluate(parse('<p @for="array" @each="value">{{ value }}</p>'), [{ array: new Map([['x', 'xx'], ['y', 'yy'], ['z', 'zz']]) }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["xx"]
            },
            {
              tag: "p",
              children: ["yy"]
            },
            {
              tag: "p",
              children: ["zz"]
            }
          ]
        })
      })
      it('evaluate: @for Map: loop', () => {
        const tree = evaluate(parse('<p @for="array">{{ loop.key }}|{{ loop.value }}|{{ loop.index }}|{{ loop.size }}|{{ loop.isFirst }}|{{ loop.isLast }}</p>'), [{ array: new Map([['x', 'xx'], ['y', 'yy'], ['z', 'zz']]) }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x|xx|0|3|true|false"]
            },
            {
              tag: "p",
              children: ["y|yy|1|3|false|false"]
            },
            {
              tag: "p",
              children: ["z|zz|2|3|false|true"]
            }
          ]
        })
      })
      it('evaluate: @for iterator: @each', () => {
        function* generate(){
            yield 'x'
            yield 'y'
            yield 'z'
        }
        const tree = evaluate(parse('<p @for="array" @each="value">{{ value }}</p>'), [{ array: generate() }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x"]
            },
            {
              tag: "p",
              children: ["y"]
            },
            {
              tag: "p",
              children: ["z"]
            }
          ]
        })
      })
      it('evaluate: @for iterator: loop', () => {
        function* generate(){
            yield 'x'
            yield 'y'
            yield 'z'
        }
        const tree = evaluate(parse('<p @for="array">{{ loop.key }}|{{ loop.value }}|{{ loop.index }}|{{ loop.size }}|{{ loop.isFirst }}|{{ loop.isLast }}</p>'), [{ array: generate() }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["0|x|0|3|true|false"]
            },
            {
              tag: "p",
              children: ["1|y|1|3|false|false"]
            },
            {
              tag: "p",
              children: ["2|z|2|3|false|true"]
            }
          ]
        })
      })
      it('evaluate: @for with text', () => {
        const tree = evaluate(parse('a<p @for="array"></p> b'), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            'a',
            { tag: "p" },
            { tag: "p" },
            { tag: "p" },
            2,
            ' b'
          ]
        })
      })
      it('evaluate: @for empty with text', () => {
        const tree = evaluate(parse('a<p @for="array"></p> b'), [{ array: [] }])
        equal(tree, {
          children: [
            'a',
            2,
            ' b'
          ]
        })
      })
    })

    describe(': <group>', function() {
      it('evaluate: group only', () => {
        const tree = evaluate(parse('<group></group>'))
        equal(tree, {})
      })
      it('evaluate: group', () => {
        const tree = evaluate(parse('<group>Hello <span>beako</span></group>'))
        equal(tree, {
          children: [
            "Hello ",
            {
              tag: "span",
              children: ["beako"]
            }
          ]
        })
      })
      it('evaluate: group chain', () => {
        const tree = evaluate(parse('<group>Hello <group>beako</group>!</group>'))
        equal(tree, {
          children: [ "Hello ", "beako", 3, '!' ]
        })
      })
    })

    describe(': expand', function() {
      it('evaluate: expand no template', () => {
        const tree = evaluate(parse('<p>{{ template }}</p>'))
        equal(tree, {
          children: [{ tag: "p" }]
        })
      })
      it('evaluate: expand template', () => {
        const template = parse('<div></div>')
        const tree = evaluate(parse('<p>{{ template }}</p>'), [{ template }])
        equal(tree, {
          children: [{
            tag: "p",
            children: [{ tag: "div" }]
          }]
        })
      })
      it('evaluate: expand template in group', () => {
        const template = parse('<div></div>')
        const tree = evaluate(parse('<group>{{ template }}</group>'), [{ template }])
        equal(tree, {
          children: [{ tag: "div" }]
        })
      })
      it('evaluate: expand template assign data', () => {
        const template = parse('<div>{{ name }}</div>')
        const tree = evaluate(parse('<p>{{ template }}</p>'), [{ template, name: 'beako' }])
        equal(tree, {
          children: [{
            tag: "p",
            children: [{
              tag: "div",
              children: ['beako']
            }]
          }]
        })
      })
      it('evaluate: expand template chain', () => {
        const template1 = parse('<div>{{ template2 }}</div>')
        const template2 = parse('<h2></h2>')
        const tree = evaluate(parse('<p>{{ template1 }}</p>'), [{ template1, template2 }])
        equal(tree, {
          children: [{
            tag: "p",
            children: [{
              tag: "div",
              children: [{ tag: "h2" }]
            }]
          }]
        })
      })
      it('evaluate: expand no template with text', () => {
        const tree = evaluate(parse('<p>{{ template1 }}</p> b'))
        equal(tree, {
          children: [{ tag: "p" }, ' b']
        })
      })
      it('evaluate: @if true and expand template', () => {
        const template = parse('<div></div>')
        const tree = evaluate(parse('<p @if="isActive">{{ template }}</p>'), [{ template, isActive: true }])
        equal(tree, {
          children: [{
            tag: "p",
            children: [{ tag: "div" }]
          }]
        })
      })
    })

    describe(': combinate', function() {
      it('evaluate: @if and @for', () => {
        const tree = evaluate(parse(`<p @for="array" @if="loop.value !== 'y'">{{ loop.value }}</p>`), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x"]
            },
            {
              tag: "p",
              children: ["z"]
            }
          ]
        })
      })
      it('evaluate: @if, @else and @for', () => {
        const tree = evaluate(parse(`<p @for="array" @if="loop.value !== 'y'">{{ loop.value }}</p><div @else>{{ loop.value }}</div>`), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x"]
            },
            {
              tag: "div",
              children: ["y"]
            },
            {
              tag: "p",
              children: ["z"]
            }
          ]
        })
      })
      it('evaluate: @if true and <group>', () => {
        const tree = evaluate(parse('<group @if="isActive">Hello</group>'), [{ isActive: true }])
        equal(tree, {
          children: ["Hello"]
        })
      })
      it('evaluate: @if false and <group>', () => {
        const tree = evaluate(parse('<group @if="isActive">Hello</group>'), [{ isActive: false }])
        equal(tree, {})
      })
      it('evaluate: @if true, @else and <group>', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><group @else>Hello</group>'), [{ isActive: true }])
        equal(tree, {
          children: [{ tag: "p", }]
        })
      })
      it('evaluate: @if false, @else and <group>', () => {
        const tree = evaluate(parse('<p @if="isActive"></p><group @else>Hello</group>'), [{ isActive: false }])
        equal(tree, {
          children: ["Hello"]
        })
      })
      it('evaluate: @for and <group>', () => {
        const tree = evaluate(parse('<group @for="array">{{ loop.value }}</group>'), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: ["x", "y", "z"]
        })
      })
      it('evaluate: @if, @for and <group>', () => {
        const tree = evaluate(parse(`<group @for="array" @if="loop.value !== 'y'">{{ loop.value }}</group>`), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: ["x", "z"]
        })
      })
      it('evaluate: @if with text in @for and <group>', () => {
        const tree = evaluate(parse(`<group @for="array"><p @if="loop.value !== 'y'">{{ loop.value }}</p> b</group>`), [{ array: ['x', 'y', 'z'] }])
        equal(tree, {
          children: [
            {
              tag: "p",
              children: ["x"]
            },
            ' b',
            ' b',
            {
              tag: "p",
              children: ["z"]
            },
            ' b'
          ]
        })
      })

    })
    describe(': @for', function() {
      const xx = { name: 'xx' }
      const yy = { name: 'yy' }
      const zz = { name: 'zz' }
      const collection = [xx, yy, zz]
      it('evaluate: collection: @for array', () => {
        const tree = evaluate(parse('<p @for="collection" @each="user">{{ user.name }}</p>'), [{ collection }])
        equal(tree, {
          children: [
            { tag: "p", key: xx, children: ['xx'] },
            { tag: "p", key: yy, children: ['yy'] },
            { tag: "p", key: zz, children: ['zz'] }
          ]
        })
      })
      it('evaluate: collection: @for array loop', () => {
        const tree = evaluate(parse('<p @for="collection">{{ loop.value.name }}</p>'), [{ collection }])
        equal(tree, {
          children: [
            { tag: "p", key: xx, children: ['xx'] },
            { tag: "p", key: yy, children: ['yy'] },
            { tag: "p", key: zz, children: ['zz'] }
          ]
        })
      })
      it('evaluate: collection: @for and <group> elements', () => {
        const tree = evaluate(parse('<group @for="collection"><span>{{ loop.key }}</span><span>{{ loop.value.name }}</span></group>'), [{ collection }])
        equal(tree, {
          children: [
            { tag: "span", children: ["0"], key: xx },
            { tag: "span", children: ["xx"], key: xx },
            { tag: "span", children: ["1"], key: yy },
            { tag: "span", children: ["yy"], key: yy },
            { tag: "span", children: ["2"], key: zz },
            { tag: "span", children: ["zz"], key: zz }
          ]
        })
      })
    })
  })
})

describe('Web Components', function() {
  describe('extend()', function() {
    it('evaluate: evaluation', () => {
      const template = {
        type: 'evaluation',
        stack: [{ name: 'Hello' }],
        template: {
          type: "get",
          value: {
            type: "variable",
            name: "name"
          }
        }
      }
      const tree = evaluate(parse('{{ template }}'), [{ template }])
      equal(tree, {
        children: ["Hello"]
      })
    })
    it('evaluate: evaluation override', () => {
      const template = {
        type: 'evaluation',
        stack: [{ name: 'Hello' }],
        template: {
          type: "get",
          value: {
            type: "variable",
            name: "name"
          }
        }
      }
      const tree = evaluate(parse('{{ template }}'), [{ template, name: 'Beako' }])
      equal(tree, {
        children: ["Beako"]
      })
    })
    it('evaluate: evaluation <group>', () => {
      const template = {
        type: 'evaluation',
        stack: [{ name: 'Hello' }],
        template: {
          type: "group",
          children: [
            {
              type: "get",
              value: {
                type: "variable",
                name: "name"
              }
            },
            '!'
          ]
        }
      }
      const tree = evaluate(parse('{{ template }}'), [{ template }])
      equal(tree, {
        children: ["Hello!"]
      })
    })
  })

  describe('define()', function() {
    it('define string', async () => {
      define('define-1', `Hello beako!`)
      document.getElementById('define_target1').innerHTML = '<define-1>Hello world!</define-1>'
      await sleep()
      const el = document.querySelector('define-1')
      equal(el.tagName, 'DEFINE-1')
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
    it('define template', async () => {
      define('define-2', parse(`Hello beako!`))
      document.getElementById('define_target2').innerHTML = '<define-2>Hello world!</define-2>'
      await sleep()
      const el = document.querySelector('define-2')
      equal(el.tagName, 'DEFINE-2')
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
    it('define string and data', async () => {
      define('define-3', `Hello {{ name }}!`, { name: 'beako' })
      document.getElementById('define_target3').innerHTML = '<define-3>Hello world!</define-3>'
      await sleep()
      const el = document.querySelector('define-3')
      equal(el.tagName, 'DEFINE-3')
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
    it('define component', async () => {
      define('define-4', compact(`Hello beako!`))
      document.getElementById('define_target4').innerHTML = '<define-4>Hello world!</define-4>'
      await sleep()
      const el = document.querySelector('define-4')
      equal(el.tagName, 'DEFINE-4')
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
  })

  describe('hack()', function() {
    it('hack string', async () => {
      const el = document.querySelector('#hack_target1')
      hack(el, `Hello beako!`)
      await sleep()
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
    it('hack template', async () => {
      const el = document.querySelector('#hack_target2')
      hack(el, parse(`Hello beako!`))
      await sleep()
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
    it('hack string and data', async () => {
      const el = document.querySelector('#hack_target3')
      hack(el, `Hello {{ name }}!`, { name: 'beako' })
      await sleep()
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
    it('hack component', async () => {
      const el = document.querySelector('#hack_target4')
      hack(el, compact(`Hello beako!`))
      await sleep()
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })
  })

  describe('compact()', function() {
    it('compact slot', async () => {
      const el = document.querySelector('#compact_target1')
      const component = compact(`<slot name="my-text">Hello world!</slot>`)
      hack(el, component)
      await sleep()
      el.innerHTML = `<span slot="my-text">Hello beako!</span>`
      equal(el.innerText, 'Hello beako!')
      equal(el.shadowRoot.querySelector('slot').innerHTML, 'Hello world!')
      equal(el.shadowRoot.querySelector('slot').assignedElements()[0].innerHTML, 'Hello beako!')
    })

    it('compact use constructer', async () => {
      const el = document.querySelector('#compact_target2')
      const component = compact(`Hello {{ name }}!`, () => {
        return [{ name: 'beako' }]
      })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.innerHTML, 'Hello beako!')
    })

    it('compact use constructer with receive from HTML', async () => {
      const el = document.querySelector('#compact_target3')
      const component = compact(`Hello {{ name }}!`, async ({ props }) => {
        const { name } = await receive(props, ['name'])
        return [{ name }]
      })
      define('compact-3', component)
      el.innerHTML = '<compact-3 name="beako"></compact-5>'
      await sleep()
      const root = document.querySelector('compact-3')
      equal(root.shadowRoot.innerHTML, 'Hello beako!')
    })

    it('compact use constructer with receive from setAttribute', async () => {
      const el = document.querySelector('#compact_target4')
      const component = compact(`Hello {{ name }}!`, async ({ props }) => {
        const { name } = await receive(props, ['name'])
        return [{ name }]
      })
      define('compact-4', component)
      el.innerHTML = '<compact-4 name="beako"></compact-4>'
      const root = document.querySelector('compact-4')
      root.setAttribute('name', 'beako')
      await sleep()
      equal(root.shadowRoot.innerHTML, 'Hello beako!')
    })

    it('compact local component', async () => {
      const el = document.querySelector('#compact_target5')
      const local = compact('<p>Hello {{ name }}!</p>', { name: 'beako' })
      const component = compact('<hello></hello>', { hello: local })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('p').innerText, 'Hello beako!')
    })
  })

  describe('sync data', function() {

    it('compact share data on brothers', async () => {
      const el1 = document.querySelector('#sync_target1_1')
      const el2 = document.querySelector('#sync_target1_2')
      const data = {
        name: 'beako'
      }
      const component1 = compact('<p>Hello {{ name }}!</p>', data)
      const component2 = compact('<p>Welcome {{ name }}!</p>', data)
      hack(el1, component1)
      hack(el2, component2)
      await sleep()
      equal(el1.shadowRoot.querySelector('p').innerText, 'Hello beako!')
      equal(el2.shadowRoot.querySelector('p').innerText, 'Welcome beako!')
    })

    it('compact share data on childe scope', async () => {
      const el = document.querySelector('#sync_target2')
      const component = compact(
        `
          <p>Hello {{ name }}!</p>
          <child></child>
        `,
        () => {
          const data = watch({
            name: 'world'
          })

          const child = compact('', () => {
            data.name = 'beako'
          })

          return [data, { child }]
        }
      )
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelector('p').innerText, 'Hello beako!')
    })

    it('compact receive props', async () => {
      const el = document.querySelector('#sync_target3')
      const local = compact('<p>Hello {{ name }}!</p>')
      const component = compact('<hello name:="name"></hello>', { hello: local, name: 'beako' })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('p').innerText, 'Hello beako!')
    })
    // TODO: test seal

    it('expand content', async () => {
      const el = document.querySelector('#sync_target4')
      const local = compact(`<group @for="[1, 2, 3]" @if="content">{{ content }}</group><p @else>{{ loop.value }}</p>`)
      const component = compact(`
        <local></local>
        <local><span>{{ loop.value + add }}</span></local>
      `, { local, add: 2 })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[0].innerText, '1')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[1].innerText, '2')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[2].innerText, '3')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('span')[0].innerText, '3')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('span')[1].innerText, '4')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('span')[2].innerText, '5')
    })

    it('expand @as', async () => {
      const el = document.querySelector('#sync_target5')
      const local = compact(`<group @for="[1, 2, 3]" @if="num">{{ num }}</group><p @else>{{ loop.value }}</p>`)
      const component = compact(`
        <local></local>
        <local><span @as="num">{{ loop.value + add }}</span></local>
      `, { local, add: 2 })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[0].innerText, '1')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[1].innerText, '2')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[2].innerText, '3')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('span')[0].innerText, '3')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('span')[1].innerText, '4')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('span')[2].innerText, '5')
    })

    it('expand @as and <group>', async () => {
      const el = document.querySelector('#sync_target6')
      const local = compact(`{{ header }}`)
      const component = compact(`
        <local>
          <group @as="header">
            <h2>Beako.js</h2>
            <p>Welcome!</p>
          </group>
        </local>
      `, { local })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('h2').innerText, 'Beako.js')
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('p').innerText, 'Welcome!')
    })

    it('expand content, @as and slot', async () => {
      const el = document.querySelector('#sync_target7')
      const local = compact(`
        {{ header }}
        {{ content }}
        <slot name="footer"></slot>
      `)
      const component = compact(`
        <local>
          <h2 @as="header">Welcome!</h2>
          <button>Click me</button>
          <div slot="footer">Good bye!</div>
        </local>
      `, { local })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('h2').innerText, 'Welcome!')
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('button').innerText, 'Click me')
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('slot').assignedElements()[0].innerHTML, 'Good bye!')
    })

    it('expand no content', async () => {
      const el = document.querySelector('#sync_target8')
      const local = compact(`<group @for="[1, 2, 3]" @if="content">{{ content }}</group><p @else>{{ loop.value }}</p>`)
      const component = compact(`
        <local></local>
        <local><span @as="num">{{ loop.value + add }}</span><span slot="header">Hello</span></local>
      `, { local, add: 2 })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[0].innerText, '1')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[1].innerText, '2')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[0].shadowRoot.querySelectorAll('p')[2].innerText, '3')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('p')[0].innerText, '1')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('p')[1].innerText, '2')
      equal(el.shadowRoot.querySelectorAll('beako-entity')[1].shadowRoot.querySelectorAll('p')[2].innerText, '3')
    })

    it('expand chain', async () => {
      const el = document.querySelector('#sync_target9')
      const local = compact(`{{ content }}`)
      const component = compact(`
        <local>
          <span @as="num">{{ add }}</span>
          {{ num }}
        </local>
      `, { local, add: 2 })
      hack(el, component)
      await sleep()
      equal(el.shadowRoot.querySelector('beako-entity').shadowRoot.querySelector('span').innerText, '2')
    })
  })
})

mocha.run()
</script>
